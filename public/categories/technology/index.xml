<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technology on Universe</title>
    <link>https://leidu.github.io/blogs/categories/technology/</link>
    <description>Recent content in technology on Universe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jun 2020 21:28:09 +0800</lastBuildDate>
    
	<atom:link href="https://leidu.github.io/blogs/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ReplacementAlgorithm</title>
      <link>https://leidu.github.io/blogs/replacementalgorithm/</link>
      <pubDate>Sun, 28 Jun 2020 21:28:09 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/replacementalgorithm/</guid>
      <description>引言  进程运行时，若其所要访问的页面不在内存，而需把他们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序和数据送到磁盘的对换区中。这种把选择换出页面的算法称为页面置换算法。
例子  要求使用最佳置换算法，先进先出算法，最近最久置换算法求解置换次数和缺页中断(使用的是三个物理块)
                           7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1    最佳置换算法(Optimal)  这是一种理论上的算法。思想：选择的被淘汰页面是以后永远不使用的，或在很长一段时间内不在被访问的页面。强调未来性。
优点：保证获得最低的缺页率。
缺点：由于未来是不可确定的，造成了一个进程在内存的若干个页面中，哪一个页面是未来最长时间不再被访问的，这是不可预知的，但可以通过该算法去评估其他算法。
解:
                           7 7 7 2  2  2   2   2    7      0 0 0  0  4   0   0    0       1 1  3  3   3   1    1      解法:由于有三个物理块，可以放入三个页面。第一个物理块放入7，第二个物理块放入0，第三个物理块放入1，这时物理块中已没有多余的空间放入页面2，所以需要置换出页面。根据最佳置换算法的思想，置换出以后永远不使用的或很长一段时间不使用的页面。通过查找7,0,1在以后使用的情况来比较分析，7在第18次访问时调入内存中，0在第4次访问时时调入内存，而1则在第12次时访问调入内存，所以得到7在很长一段时间不会使用，把7置换出去，把2调入内存。如果所置换的页面在内存中存在则不进行置换。</description>
    </item>
    
    <item>
      <title>Music Player base on  MUI framework</title>
      <link>https://leidu.github.io/blogs/musicplayer/</link>
      <pubDate>Sun, 21 Jun 2020 18:59:47 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/musicplayer/</guid>
      <description>这是一个基于mui框架实现的一个网页随机音乐播放,主要功能有播放与暂停,随机切歌,静音三个。
需求建模  原型界面  设计软件  应用端
Axure RP 网页版
摹客原型     数据模型 业务模型  框架  应用架构
描述IT系统功能和技术实现的内容 分类  C结构
Client,最早的一种初始分类单机结构,不涉及联网的客户端,如单机游戏 S结构
Server,用于网络通信的一种服务结构,使用Socket(套接字)来传输数据,包含TCP和UDP两种协议 C/S结构
Client/Server,一种端应用,原来的APP应用,优点:稳定,功能强大;缺点:更新不及时,跨平台弱 B结构 B/S结构
Browser/Server,一种页应用,直接在网页中进行操作. C/S+B/S混合结构
以C/S为主,B/S为辅的一种结构,如微信小程序,快应用,现代版QQ B/S+C/S混合结构
以B/S为主,C/S为辅的一种结构,如在线直播,在线电影   开发模型
主要是MVC,其中包含MVC 1.0和MVC 2.0,其中MVVP是对MVC的扩展 开发框架  weex quickapp weixin app uniapp mui    跨域与协议   跨域 定义:网页应用中的一种安全机制,域:作用域,网页应用中的ip/主机名/域名
跨域方式:设置头部(request:伪造);设置响应许可(运行那些ip/域名来访问,服务器就做出响应);JSON;webservice
  协议
协议头://host:port/contextroot/path
  跨域的必要条件
协议头不同;主机名不同;IP协议不同;域名不同;端口号不同;上下文根不同</description>
    </item>
    
    <item>
      <title>Analysis of value range based on java type</title>
      <link>https://leidu.github.io/blogs/type-value-analysis/</link>
      <pubDate>Tue, 12 May 2020 21:48:09 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/type-value-analysis/</guid>
      <description> 求&amp;quot;2^100 % 5&amp;quot;的值，通过分析，需要注意的是在定义时所使用的数据类型，如果定义的数据类型过小，获得的结果就会越界，不能取得正确的结果。
基本类型的取值范围表    类型 存储需求 取值范围     byte 1 -127~128   short 2 -2^15~2^15-1   int 4 -2^31~2^31-1   long 8 -2^63~2^63-1   float 4 -3.40282310^38~3.40282310^38   double 8 -1.797710^308~1.97710^308   char 2    boolean 1 true 或 false    </description>
    </item>
    
    <item>
      <title>Javascript And Image II</title>
      <link>https://leidu.github.io/blogs/javascriptandimg_2/</link>
      <pubDate>Sun, 10 May 2020 22:53:33 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/javascriptandimg_2/</guid>
      <description>根据上一次的“基于javaScript&amp;quot;的改变图片，有一定的缺陷，如果浏览器不支持 javaScript会怎么样。而为了更高效的执行代码，现在都采用一个模式——代码分 离，这种模式使代码更高效的执行，也更好的让人阅读。接下来，就是讲解HTML 和javaScript的分离。
html
 ... &amp;lt;div id=&amp;quot;imgs&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;your image path&amp;quot; title=&amp;quot;your description&amp;quot; /&amp;gt; &amp;lt;a href=&amp;quot;your image path&amp;quot; title=&amp;quot;your description&amp;quot; /&amp;gt; ... &amp;lt;div&amp;gt; &amp;lt;img id=&amp;quot;placeholder&amp;quot; src=&amp;quot;your image path&amp;quot; /&amp;gt; &amp;lt;p id=&amp;quot;description&amp;quot;&amp;gt;description&amp;lt;/p&amp;gt; ...  javaScript 其中的判断语句用于判断浏览器是否支持javaScript。
function grally() { if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById(&amp;quot;imgs&amp;quot;)) return false; var gallery = document.getElementById(&amp;quot;imgs&amp;quot;); var links = gallery.getElementsByTagName(&amp;quot;a&amp;quot;); for(var i = 0; i &amp;lt; links.length; i++) { links[i].onclick = function() { return showPic(this) ?</description>
    </item>
    
    <item>
      <title>Javascript And Image I</title>
      <link>https://leidu.github.io/blogs/javascriptandimg_1/</link>
      <pubDate>Sun, 10 May 2020 22:36:52 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/javascriptandimg_1/</guid>
      <description>今天主要研究的是—javaScript图片库,通过点击一条超连接文本，不用跳转直接在 本页面显示图片。这个主要用到了占位符，通过占位符图片替换成自己想要查 看的图片。 思路：
 获取超链接文件的路径
获取占位符图片
把超链接的文件放到占位符图片里
 动态改变图片
 标记 我认为这里的标记在这里是html文件里面所使用的标签。如以下部分代码:   ... &amp;lt;a href=&amp;quot;your image path&amp;quot; title=&amp;quot;your image description&amp;quot; onclick=&amp;quot;showPic(this); return false;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;quot;your image path&amp;quot; title=&amp;quot;your image description&amp;quot; onclick=&amp;quot;showPic(this); return false;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt; ... &amp;lt;img id=&amp;quot;placeholder&amp;quot; src=&amp;quot;your default image path or null&amp;quot; /&amp;gt; ...   在showPic(this)中的&amp;rsquo;this’，含义是“这个对象”，在这里指“这个元素节 点。把获取到的节点通过点击事件把参数值传到javaScript中，以便使用。
javaScript
 &amp;lt;script&amp;gt; function showPic(whichpic) { var source = whichpic.getAttribute(&amp;quot;href&amp;quot;); var placeholder = document.getElementById(&amp;quot;placeholder&amp;quot;); placeholder.setAttribute(&amp;quot;src&amp;quot;, source); } &amp;lt;/script&amp;gt;   whichpic代表一个元素节点，接收来自html中this传过来的值，具体是指向某个图片 元素。通过whichpic.</description>
    </item>
    
    <item>
      <title>Odd</title>
      <link>https://leidu.github.io/blogs/odd/</link>
      <pubDate>Sun, 10 May 2020 22:29:17 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/odd/</guid>
      <description>今天看过一片文章——完成代码，判断一个整数是否是奇数： public boolean isOdd(int i) 看到这道题，我最开始认为很简单，但就是这么一道题让我明白了一件事，我们不是一个简单的码工，而是一个思想者，学会理解事物的本质。
通过看到题目，我们很一所当然的想到，如果 i % 2 != 0时，就打印出结果——System.out.println(“i是奇数”)。其实不然，要想到这里要求返回一个boolean 值。boolean是布尔型，返回true或false。
在看后面的回答时，还要明白一个问题，取模运算和位运算的关系，这两者哪一个运行 速度更快。其实这两者的运算速度差不多，为什么。个人认为取模运算和位运算都是在进行 二进制的转换运算，而也提到了奇数和偶数转换为二进制时，奇数最后一位是1，偶数最后一 位是0，其实可以想到，取模运算在最后转换为二进制是倒排顺序，其实是使用到了栈的先进后出的原则，而位运算我认为运用了队列的先进先出的原则。
e.g 求5和6的奇数和偶数的二进制
   数值 二进制     奇数 5 101   偶数 6 110    通过对比，把数值转换为二进制，奇数和偶数相当于负数的补码，即+1操作。
REFERENCE [1] (转载) https://mp.weixin.qq.com/s/oSrLRHYxG8g13dY_jyr-Yw</description>
    </item>
    
    <item>
      <title>Change Color</title>
      <link>https://leidu.github.io/blogs/change-color/</link>
      <pubDate>Sun, 10 May 2020 22:21:59 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/change-color/</guid>
      <description>在代码中主要用到了javaScript中的onchange事件。onchange事件可以用于input text、textarea、select option等HTML Form元素上，当元素内容改变时就触发这 个事件来执行你所写的javaScript程序。
  变背景
html
   &amp;lt;select id=&amp;quot;changeBackground&amp;quot; onchange=&amp;quot;changeBg()&amp;quot;&amp;gt; &amp;lt;option value=&amp;quot;blue&amp;quot;&amp;gt;blue&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;quot;pink&amp;quot;&amp;gt;pink&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;quot;gray&amp;quot;&amp;gt;gray&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt;  js
 &amp;lt;script&amp;gt; function changeBg(color) { var getSelectValue = document.getElementById(&amp;quot;changeBackground&amp;quot;).value; document.bgColor = getSelectValue; } &amp;lt;/script&amp;gt;    变字体颜色
html
   &amp;lt;select id=&amp;quot;changeFontColor&amp;quot; onchange=&amp;quot;changeFC(value)&amp;quot; &amp;gt; &amp;lt;option value=1&amp;gt;selete, please&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;quot;blue&amp;quot;&amp;gt;blue&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;quot;pink&amp;quot;&amp;gt;pink&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;quot;gray&amp;quot;&amp;gt;gray&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;div id=&amp;quot;text&amp;quot;&amp;gt;She is my mother!&amp;lt;/div&amp;gt;  js
第一种方式，通过直接使用onchange事件来实现
 &amp;lt;script&amp;gt; function chageFC(color) { document.</description>
    </item>
    
    <item>
      <title>File</title>
      <link>https://leidu.github.io/blogs/file/</link>
      <pubDate>Sun, 10 May 2020 22:13:51 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/file/</guid>
      <description>在JDK中，File是从1.0开始就有的，而Files和Path是JDK 1.7才出现的。　File
 来自于java.io包中，其中就有一个File类，这个类可以对文件进行读取，可以对其文件 进行创建删除和修改。　 构造函数
File(String path); 如果path是实际路径，则表示文件目录；如果path是实际文件名，则就是该对象是文件。
File(String path, String name); path表示目录，name表示文件。
File(File dir, String name); dir表示对象的路径，name表示文件名。　  Files
 来自于java.nio包中，其中就有一个Files类，这个类可以用来移除或重命名文件，或者 查询拍文件下最后被修改的时间，主要关心文件的内容。　Path
 来自于java.nio包中，其中就有一个Path类，表示一个目录名序列，其后可以跟着一个文 件名，主要关心磁盘上如何存储文件。 Path类实际一个接口类，不能被实例化，在NIO中也是通过流的方式在工作。在Paths中有一个 静态的Paths.get(String first, String&amp;hellip;more)方法接受一个或多个字符串，并将他们默认的文件系统的路径分隔符连接起 来。然后解析连接起来的结果。如果其表示的不是给定文件系统中的合法路径，就会抛出 InvaildPathException异常。而连接起来的对象就是Path。如:Path pa = Paths.get(&amp;quot;/temp”, “my.config”);
Paths方法
根据jdk1.8的源码来看，有两个方法，如下：
 方法
static Path get(String first, String… more
static Path get(URI uri)  Path方法
 Path resolve(Path other)
Path resolve(String other)
如果other是绝对路径，则返回oher；否则返回通过连接this和other连接得到的路径 Path resolveSibling(Path other)
Path resolveSibling(String other)</description>
    </item>
    
    <item>
      <title>String</title>
      <link>https://leidu.github.io/blogs/string/</link>
      <pubDate>Sun, 10 May 2020 22:05:13 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/string/</guid>
      <description>从概念上将，Java字符串就是Unicode字符序列。e.g:串&amp;quot;Java\u2122由5个Unicode字符J a v a和TM。Java没有内置的的字符串，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。每一个用引号括起来的字符串就是String类的一个实例。 在字符串中，分为不可变字符串(String)和可变字符串(StringBuffer和StringBuilder)。
String  String类在JDK API中使用final修饰的，意为不可修改类。以下是String类图。 public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { ... }   String的创建   String str = “She is my mother”; String str2 = “She is my mother”; String str3 = new String(“She is my mother”); System.out.println(str == str2); //true System.out.println(str.equals(str2)); //true System.out.println(str == str3); //false System.out.println(str.equals(str3)); //true   通过分析，虽然str,str2,str3都是指向一个地址，但“str == str3”的值是false，可以得到一个结果，str和 str2这两个对象是在常量池中保存，而str3是通过关键字new创建的一个对象，被存放在了堆内存中，而通过equals比较时，str3被重写了，重写过后变成了值比较，如&amp;quot;str == str2&amp;rdquo;。
 System.out.println(“She is my mother, and her name” + name);   通过println()里的语句，‘+’是一个连接符，如果在一条语句里，存在字符串和‘+’ ，那么这条语句就还是字符串；如果是数值(2+3)，则这时‘+’就起算术运算。</description>
    </item>
    
    <item>
      <title>Bitwise Operators</title>
      <link>https://leidu.github.io/blogs/bitwise-operators/</link>
      <pubDate>Sun, 10 May 2020 21:43:17 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/bitwise-operators/</guid>
      <description>位操作是程序设计中对位模式按位或二进制数的一元或二元的操作。
位运算中要注意：左边最高位是符号位，如果是正数，则最高位用0表示， 否则用1表示；如果是负数，则采用补码表示。
在计算机中由于位数的不同所引用的二进制数也不同，在现在大多是32位和64位，以下的例子中，以8位来进行实现。 但在学习位运算时，还要先了解进制等相关的知识。
进制   二进制
二进制(B)：基于为2的计数制。二进制是“逢2进1”，每一位只有0和1两种状态， 位权为2的各次幂。
  十进制
十进制(D)计数方法为“逢10进1”，一个十进制数的每一位都只有10种状态，分别 用0～9等10个数码表示。
  八进制
八进制(O)数的基数为8，进位规则为“逢8进1”，使用0~7等8个数码，位权是8的 各次幂。
  十六进制
十六进制(H)的基数是16，进位规则为“逢16进1”，使用0~9，A～F等16个数码， 位权是16的各次幂。
  二进制原码、反码、补码   原码
原码是一种计算机中对数字的二进制定点表示方法。规则：如果数值是正数，则 最高符号位是0，如果是负数，最高符号位是1，其他位不变。
  反码
规则：如果数值是正数，则反码和原码相同；如果是负数，则最高符号位是1，其 它位分别取反。
  补码
补码是计算机表示数据的一般形式，规则是如果是正数，则补码和原码一样；如 果是负数，则在反码的基础上+1。
  原码、反码、补码总结
如果所求的数值为正数，则原码、反码、补码都是相同的；如果所求的数值为负 数，则原码的符号位是1，不是0；反码符号位不变，其余位取反；补码是在反码的基础 上+1。
e.g 求8和-8的原码、反码和补码
     数值 原码 反码 补码     8 0 000 1000 0 000 1000 0 000 1000   -8 1 000 1000 1 111 0111 1 000 1001    位运算  按位与</description>
    </item>
    
    <item>
      <title>Soft Design</title>
      <link>https://leidu.github.io/blogs/soft-design/</link>
      <pubDate>Sun, 10 May 2020 21:34:16 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/soft-design/</guid>
      <description>软件体系结构  软件体系结构产生原因
软件体系结构产生的原因是软件危机的出现。 软件危机的表现
1.软件成本日益增长
2.开发进度难以控制
3.软件质量差
4.软件维护困难
软件危机的原因
1.用户需求不明确
2.缺乏正确的理论指导
3.软件规模原来越大
4.软件复杂度越来越高 克服软件危机
主要从两方面入手，即技术和管理。  设计模式简要  软件设计模式的分类
1.创建型：类与实例化时使用的模式
2.结构型：描述类与对象怎样结合
3.行为型：设计到算法和对象职责间的分配     创建 结构 行为     类 工厂方法 适配器 解释器模板方法   对象 抽象方法 桥接 责任链　命令   生成器 组成 迭代器 中介者   原型 装饰 备忘录 观察者   单例 享元 代理 状态 策略 访问者    七大原则   单一职责原则</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://leidu.github.io/blogs/mysql/</link>
      <pubDate>Sun, 10 May 2020 21:18:23 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/mysql/</guid>
      <description>MySQL是一个开源的关系型数据库管理系统，由瑞典MySQL公司开发，属于Oracle旗下产品。
安装[^1] 下载并解压 下载   创建存放mysql文件夹
mkdir /media/universe/_dde_data/mysql
  解压并赋予权限
tar -xJvf mysql.tar.xz
  创建data文件夹和log文件夹并赋予权限
mkdir /media/universe/_dde_data/mysql/data mkdir /media/universe/_dde_data/mysql/log
  配置
创建mysql用户和组
groupadd mysql
useradd mysql
编写my.cnf配置并移到/etc目录
   [mysqld] port=3306 pid-file=/media/universe/_dde_data/mysql/data/mysqld.pid socket=/media/universe/_dde_data/mysql/data/mysql.sock log-error=/media/universe/_dde_data/mysql/log/mysqld.log basedir=/media/universe/_dde_data/mysql datadir=/media/universe/_dde_data/mysql/data [client] port=3306 socket=/media/universe/_dde_data/mysql/data/mysqld.sock  把配置文件移到其他文件下sudo mv /media/universe/_dde_data/my.cnf /etc
进行初始化 /media/universe/_dde_data/mysql/bin/mysqld --initialize --user=mysql --basedir=/media/universe/_dde_data/mysql --datadir=/media/universe/_dde_data/mysql/data
注意：如果在my.cnf里面配置了mysql的basedir和datadir不用在初始化里在写，如果写了在进行初始化的时候会报错。
测试mysql
cd mysql/bin/，执行./mysqld_safe，启动mysql初始化状态
cd mysql/support-files,执行mysql.server, 启动mysql服务
cd mysql/bin,执行./mysql -u用户名 -p密码, 进去mysql命令状态
注意：密码在开始的时候是随机生成的，在mysqld.log里可以找到，在进入mysql里面可以进行修改。
如果mysql测试能够正常使用，可以通过软连接的方式吧执行命令放到相应的文件夹下，在下次使用是直接使用相应的命令即可。 创建软连接</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://leidu.github.io/blogs/linux/</link>
      <pubDate>Sun, 10 May 2020 20:08:01 +0800</pubDate>
      
      <guid>https://leidu.github.io/blogs/linux/</guid>
      <description>Linux是由赫尔辛基大学的Linus Torvalds开发的，是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、 多任务、支持多线程和多CPU的操作系统。
‘$&#39;符号的使用^1    序号 变量与说明     1 $0,表示当前执行的脚本的文件名   2 $1…n,1..n对应于调用脚本的参数   3 $#,表示提供给脚本的参数数量   4 $*,所有参数都使用双括号引起来，如果脚本收到两个参数,则$*=$1 $2   5 $@,所有从参数都使用单独用双引号引起来,则$@=$1 $2   6 $?,最后执行的命令的退出状态   7 $$,当前shell的进程号   8 $!,最后一个后台命令的进程号     notify: 当$与*、@、1等组合时，要使用转义字符”\&amp;rdquo;  通配符的使用 不管在脚本语言中，还是在Java，python等语言中，正则表达式都是很重要的，而在其中，通配符的 使用也是很频繁的。
   序号 说明 例子     1 *,匹配所有字符 ls file*   2 ?</description>
    </item>
    
  </channel>
</rss>